import networkx as nx
from funlib.math import decode64, encode64
from candidate_graph import iterate_tree
from linajea_cost_test import get_merge_graph_from_array
from segmentation import segment_stats
import numpy as np

def generate_tracks(z, graph, selected_key='selected', debug=False):
    t = 0
    fragments = z['Fragments'][:]
    merge_tree = z['Merge_tree/Merge/'+str(t)]
    scores = z['Merge_tree/Scoring/'+str(t)]
    merge_tree = get_merge_graph_from_array(merge_tree, scores)

    # Idk
    #id, positions, _ = segment_stats(track[0], 0)
    #correct_id_num = count_anno_id(id,merge_tree)
    #print('correct_id_num:',correct_id_num)

    # Select starting node
    select_graph = get_select_graph(graph, key=selected_key)
    node_start = select_nodes_t(select_graph, 0)
    if debug: print('the ids of nodes in t0 are:', node_start)

    # create a labels list that prevent napari error  (napari can only read labels under int32)
    labels = []
    for node in select_graph.nodes:
        labels.append(node)
        
    track_data = []

    # Generate tracks from graph
    l=0
    cell_mask = np.zeros(fragments.shape)
    track_graph = {}
    #track_graph = nx.DiGraph()# graph for arboretum
    for start in node_start:    
        paths = find_all_paths(select_graph, start)
        pick = pick_nodes_once(paths,select_graph)

        for path in pick:
            label = labels.index(path[0]) # choose first node id as label
            for node in path:
                cor = decode64(int(node),dims=5,bits=[9,12,12,12,19])
                track_data.append([label,cor[0],cor[1],cor[2],cor[3]])
                if select_graph.out_degree(node) == 2:
                    for neighbor in select_graph.out_edges(node):
                            track_graph[labels.index(neighbor[1])] = [label]
                t = cor[0]
                
                ids = z['Fragment_stats/id/'+str(t)]
                merge_tree = z['Merge_tree/Merge/'+str(t)]
                scores = z['Merge_tree/Scoring/'+str(t)]
                merge_tree = get_merge_graph_from_array(merge_tree, scores)

                if merge_tree.has_node(int(node)):
                    sub_tree = iterate_tree(merge_tree, int(node))
                    for a in sub_tree:
                        if a in list(ids):
                            # a is the leave node id
                            # get the label of this leave node
                            label_a = list(ids).index(a)+1
                            cell_mask[t][fragments[t] == label_a] = label

        if len(paths)>1:
            l=l+1
            if debug:
                print('the paths are',paths)
                for path in pick:
                    print('sub-set of paths:',path)
                print('******************')

    return track_data, track_graph, cell_mask, fragments


# create annotation graph by gt_trackimage
def create_annotation_graph(gt_image):
    '''
    gt_image: ndarray image by (t,z,y,x) each cell has an annotated label. for exmaple 10000, 10001, .... 

    return
    anno_graph: nx.Digrph() which create a graph with edges.
                these edges connected node are generated by encode cell.
                e.g label n will be encode to u at time 0
                                    encode to v at time 1
                then the edge will be (v, u, source = v, target = u)
    
    '''
    time = gt_image.shape[0]
    anno_graph = nx.DiGraph()
    for label in np.unique(gt_image):
        if label == 0:
            continue   
        for t in range(time):
            mask = gt_image[t]==label
            regions = regionprops(mask.astype(int))
            for props in regions:
                z0, y0, x0 = props.centroid
                u = encode64((t, int(z0), int(y0), int(x0), int(props.area)),bits=[9,12,12,12,19])
            mask = gt_image[t]==label
            regions = regionprops(mask.astype(int))
            for props in regions:
                z0, y0, x0 = props.centroid
                v = encode64((t, int(z0), int(y0), int(x0), int(props.area)),bits=[9,12,12,12,19])
            anno_graph.add_edge(v, u, source = v, target = u)
    return anno_graph

# count the number of how many annotation id in merge tree at time t
def count_anno_id(id,merge_tree):
    '''
    merge_tree: nx.Digrph merge_tree create by waterz 
    id: ndarray (n,) 1d array store all ids in GT image
    correct_id_num: int count the number of how many annotation node(id) in merge tree
    '''
    mt_id = list(merge_tree.nodes)
    correct_id_num = len(set(id)&set(mt_id))
    return correct_id_num 

def get_select_graph(graph,key='selected'):
    '''
    get a sub-graph form graph

    graph: nx.Digraph() candidate graph with some edges has attribute 'select' = True

    return
    select_graph: nx.Digraph()  sub-graph only have edges from candidate graph with 'select' is True
  
    '''
    select_graph = nx.DiGraph()
    for u,v,data in graph.edges(data=True):
        if data[key]:
            select_graph.add_edge(v, u, source = v, target = u)
            select_graph.add_node(u, **graph.nodes[u])
            select_graph.add_node(v, **graph.nodes[v])
    return select_graph

def pick_select_edge(graph):
    '''
    graph: nx.Digraph() candidate graph with edge has attribute 'select' = True

    return
    edges: list of all edges in graph
    select_edges: list of edges with attribute 'select' == True
 
    '''
    edges = []
    selected_edges = []
    for u,v,data in graph.edges(data=True):
        edges.append((u,v))
        if data['selected']:
            selected_edges.append((u,v))
    return edges, selected_edges




def find_devison_node(select_graph):
    ''' 
    find the devision node
    select_graph: nx.Digraph()  sub-graph only have edges from graph with 'select' is True

    return
    devision_nodes: list of nodes wihch are split
    '''
    devision_nodes = []
    for node in select_graph.nodes:
        if select_graph.out_degree(node) == 2:
            devision_nodes.append(node)
    return devision_nodes

def select_nodes_t(select_graph,t):
    '''
    pick nodes at time t in select_graph

    select_graph: nx.Digraph()
    t: int 

    return
    nodes_t: a string list wich contains the nodes at time t 

    '''
    nodes_t = []
    for node in select_graph.nodes:
        #print(node)
        cor = decode64(int(node),dims = 5,bits=[9,12,12,12,19])
        if cor[0]== t:
            nodes_t.append(node)
    return nodes_t


def find_path(graph, start, end):
    '''
    find a path between star and end in graph

    graph: nx.Digrph
    start: string  the start point (node id)
    end: string  the end point (node id)

    '''
    queue = [(start, [start])]
    while queue:
        (node, path) = queue.pop(0)
        for neighbor in graph.successors(node):
            if neighbor == end:
                yield path + [end]
            else:
                queue.append((neighbor, path + [neighbor]))
                
def find_all_paths(graph, start):
    '''
    find all path with a start point (node id)

    graph: nx.Digrph
    start: string  the start point  
    '''
    paths = []
    for node in graph.nodes():
        paths.extend(list(find_path(graph, start, node)))
    return [path for i, path in enumerate(paths) if not any(path == subpath[:len(path)] for subpath in paths[:i] + paths[i+1:])]

def find_repeated_nodes(paths):
    '''
    old one. not use any more
    path =[['19316374903985664', '28569847583478785', '1055642833915906'], ['19316374903985664', '28569847583478785', '140917883278850']]
    find_repeated_nodes(path) gives
    {'19316374903985664', '28569847583478785'}

    
    once you have all path from a node e.g.'19316374903985664'
    this function give a common nodes from two different paths.

    '''
    
    node_counts = {}
    for path in paths:
        for node in path:
            node_counts[node] = node_counts.get(node, 0) + 1
    repeated_nodes = set([node for node, count in node_counts.items() if count > 1])
    return repeated_nodes

def pick_nodes_once(lst,select_graph):
    '''

    lst : a list of paths of one node (from find_all_path)
        e.g node 1 has paths [[1,2,4],[1,2,3]]
    select_graph : nx.Digraph

    return:
    create lists. onece the node split it will creat a new list

    e.g for path =[['19316374903985664', '28569847583478785', '1055642833915906'], ['19316374903985664', '28569847583478785', '140917883278850']]
    pick_nodes_once(path,select_graph)
    it gives 
    [['19316374903985664', '28569847583478785'],
    ['1055642833915906'],
    ['140917883278850']]
    '''
    output = []
    nodes = set()
    for item in lst:
        new_item = []
        for node in item:
            if node not in nodes:
                nodes.add(node)
                new_item.append(node)
                if select_graph.out_degree(node) == 2:
                    output.append(new_item)
                    new_item = []                     
        if new_item:
            output.append(new_item)
    return output